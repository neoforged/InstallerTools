
// Gradle repositories and dependencies
buildscript {
    repositories {
        gradlePluginPortal()
        mavenCentral()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.5.0'
    }
}

plugins {
  id 'net.neoforged.licenser'
  id 'com.gradleup.shadow' apply false
}

apply plugin : ProjectDefaultsPlugin
apply plugin : CliToolPlugin

gradleutils {
    setupSigning()
    setupCentralPublishing()
}

application {
    mainClass = 'net.neoforged.installertools.ConsoleTool'
}

license {
  header project.file('LICENSE-header.txt')
  include 'net/neoforged/installertools/**/*.java'
  newLine false
}

shadow {
    // We want to publish the proguard jar instead
    addShadowVariantIntoJavaComponent = false
}

dependencies {
    compileOnly(libs.jetbrains.annotations)
    implementation(libs.art)
    implementation(libs.srgutils)
    implementation(libs.jopt)
    implementation(libs.gson)
    implementation(libs.fastcsv)
    implementation(libs.asm.commons)
    implementation(libs.xz)
    implementation(libs.xdelta)
    implementation project(':cli-utils')
    implementation project(':binarypatcher')

    testImplementation(libs.bundles.junit)
}

test {
    useJUnitPlatform()
}

File proguardFile = file("build/libs/${jar.archiveBaseName.get()}-proguard-${version}.jar")

final proguardJar = tasks.register('proguardJar', proguard.gradle.ProGuardTask) {
    dependsOn shadowJar
    inputs.file(shadowJar.archiveFile)
    inputs.file(file("proguard.conf"))

    if (JavaLanguageVersion.current().asInt() <= 8) {
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {
        libraryjars "${System.getProperty('java.home')}/jmods"
    }
    libraryjars(configurations.compileClasspath)

    // Exclude superfluous licenses in META-INF/, and also exclude some unused resources from apache commons codec,
    // which compress transitively depends on
    injars(["filter": "!META-INF/maven/**/*,!META-INF/*.txt"], shadowJar.archiveFile)
    outjars proguardFile
    configuration file("proguard.conf")
}
assemble.dependsOn proguardJar

configurations {
    consumable("proguard") {
        attributes {
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
        }
    }
}

artifacts {
    add("proguard", proguardJar) {
        classifier = "fatjar"
    }
}

// create an adhoc component
final javaComponent = (AdhocComponentWithVariants) project.components.findByName("java")
javaComponent.addVariantsFromConfiguration(configurations.proguard) {
    // dependencies for this variant are considered runtime dependencies
    it.mapToMavenScope("runtime")
    // and also optional dependencies, because we don't want them to leak
    it.mapToOptional()
}

publishing {
    publications.register('mavenJava', MavenPublication) {
        from components.java

        pom {
            name = 'Installer Tools'
            description = 'A collection of command line tools that are useful for the Forge installer, that are not worth being their own standalone projects.'
        }
    }
}
